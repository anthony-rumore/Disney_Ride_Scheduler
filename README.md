# Making Your Day Magicalâ„¢
*Project 3: COP3530 Data Structures and Algorithms*

This program takes in tens of thousands of queue wait time data points from popular Magic Kingdom attractions at Walt Disney World and uses that data to build *your* perfect Disney day!

Simply select your top 6 attractions that you would like to do in a single day and our program will do the rest. We'll tell you what time you should ride each ride to minimize waiting in line and thus maximize your day.

## Authors
- Anna Albertelli
- Anh Le
- Anthony Rumore

## Starting the Program
> **This project uses C++ 2017**

### Recommended Approach: CLion
We recommend compiling and running this program in CLion. Simply create a new project matching the version of C++ and save it to your desired location. Using the built-in tools in the IDE, run the project from main.cpp.

To compile and run this program manually using g++, please see below.

### Compile using g++
Use the following command to manually compile the program via the terminal with g++.
```shell
g++ -std=c++17 main.cpp Scheduler.cpp -o disney-day 
```
### Running the Program via Terminal
Once you have compiled the program with g++, select one of the following commands to start the program depending on your operating system. 
> Note, that the Data folder **must** be located **one directory lower** than where the executable is stored. *For example, if your Data folder is stored on the Desktop, the executable must be in a different folder also on the Desktop.*

macOS and Linux:
```shell
./disney-day
```

Microsoft Windows:
```shell
disney-day.exe
```

## Using the Program

### User Input

When this program starts, users will be prompted to choose 6 Magic Kingdom attractions from a predetermined list of 20. Each attraction will be assigned a number in front of it, and users will type this number in to select each attraction.

### Output

After the program receives the attractions selected by the user, it will process historical queue data from that ride to build a schedule. The six attractions will print to the screen with an ideal time to get in line in chronological order

## How it Works

Once a user selects their 6 attractions, the program will import historical data for queue times on each of these rides. Currently, we are using stand-by wait time data for the entire months of **January and February 2024** down to nearly every minute, roughly equating to 50,000 data points per ride. All of this data is imported and stored in a custom-implemented hash map. These wait times are then averaged for each attraction for every 5-minute interval **between 9 am and 9 pm** (typical park operating hours) for all days in the data set. This data will be used to find what times of the day each attraction typically has the lowest stand-by wait time.

Each attraction will use a custom-implemented minimum heap to store the lowest wait times for that ride with the respective time attached. This will be used by the scheduler to pick the best or next-best times to fit a ride on a user's itinerary.

To build the user's day with this data, we must first schedule the rides that normally have the highest wait times first, so that valuable time slots are not wasted by attractions that typically have much lower wait times. We do this by calculating a *Ride Popularity Index (RPI)* which is basically a ride's average wait time for all time. Rides with higher RPI values are scheduled first to maximize time savings with a greedy algorithm. 

When adding an attraction to the schedule, the scheduler reserves the ride's wait time from its start time plus a 15-minute padding time. This is to account for riding the attraction itself and traveling to the next attraction scheduled. You might ask yourself this: doesn't 15 minutes sound a bit short for this buffer? From my experience, Disney often overestimates wait times by roughly 5 to 10 minutes, and our program rounds average wait times up to the nearest 5-minute interval. We feel that between the overestimation and rounding, guests will have plenty of time to get between back-to-back scheduled attractions generated by this program. 

If the scheduler attempts to schedule a ride with its lowest wait time for a time that is already occupied by another attraction on the itinerary, the ride will continue attempting its next-best minimum wait time until it can fit on the schedule. Once all the user's selected rides are scheduled, a full itinerary of arrival times and attraction names will be printed for the user in chronological order. This is the schedule the user will follow to minimize their time waiting in line!